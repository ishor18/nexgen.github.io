-- Non-Destructive SQL Setup & Update for NexGen Platform
-- Run this in the Supabase SQL Editor to update your database WITHOUT losing data.

-- 1. Create Profiles table (safe creation)
CREATE TABLE IF NOT EXISTS profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  full_name TEXT,
  email TEXT UNIQUE,
  role TEXT DEFAULT 'user' CHECK (role IN ('admin', 'user')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Safely add balance and withdrawal columns to profiles if they don't exist
DO $$ 
BEGIN 
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='balance') THEN
    ALTER TABLE profiles ADD COLUMN balance DECIMAL(12,2) DEFAULT 0.00;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='total_withdrawn') THEN
    ALTER TABLE profiles ADD COLUMN total_withdrawn DECIMAL(12,2) DEFAULT 0.00;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='views_total') THEN
    ALTER TABLE profiles ADD COLUMN views_total BIGINT DEFAULT 0;
  END IF;
END $$;

ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 2. Create Files metadata table (safe creation)
CREATE TABLE IF NOT EXISTS files (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT,
  size TEXT,
  url TEXT,
  author_id UUID REFERENCES auth.users DEFAULT auth.uid(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE files ENABLE ROW LEVEL SECURITY;

-- 3. Create Blogs table (safe creation)
CREATE TABLE IF NOT EXISTS blogs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  excerpt TEXT,
  content TEXT,
  date TEXT,
  author_id UUID REFERENCES auth.users DEFAULT auth.uid(),
  views BIGINT DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Safely add image_url and file_id to blogs if they don't exist
DO $$ 
BEGIN 
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='blogs' AND column_name='image_url') THEN
    ALTER TABLE blogs ADD COLUMN image_url TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='blogs' AND column_name='file_id') THEN
    ALTER TABLE blogs ADD COLUMN file_id BIGINT REFERENCES files(id) ON DELETE SET NULL;
  END IF;
END $$;

ALTER TABLE blogs ENABLE ROW LEVEL SECURITY;

-- 4. Re-apply Functions and Triggers (Non-destructive)

-- Function to check if a user is an admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for automatic profile creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email, role)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'full_name', 
    new.email,
    CASE WHEN new.email = 'ishoracharya977@gmail.com' THEN 'admin' ELSE 'user' end
  )
  ON CONFLICT (id) DO NOTHING; -- Prevents errors if profile somehow exists
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Safely re-attach trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Analytics Function
CREATE OR REPLACE FUNCTION increment_view_count(blog_id bigint)
RETURNS void AS $$
DECLARE
  author_uuid UUID;
BEGIN
  -- Get the author ID first
  SELECT author_id INTO author_uuid FROM blogs WHERE id = blog_id;

  -- Update blog views
  UPDATE blogs SET views = views + 1 WHERE id = blog_id;

  -- Update profile total views
  IF author_uuid IS NOT NULL THEN
    UPDATE profiles SET views_total = views_total + 1 WHERE id = author_uuid;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5. Safely re-apply Policies
-- (We drop them first to ensure they match our latest rules, but this doesn't delete data)

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Users can read own profile" ON profiles;
    DROP POLICY IF EXISTS "Users can insert own profile" ON profiles;
    DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
    DROP POLICY IF EXISTS "Admins can read all profiles" ON profiles;
    DROP POLICY IF EXISTS "Admins can delete users except superadmin" ON profiles;

    DROP POLICY IF EXISTS "Public Read Blogs" ON blogs;
    DROP POLICY IF EXISTS "Users can insert own blogs" ON blogs;
    DROP POLICY IF EXISTS "Users can delete own blogs" ON blogs;
    DROP POLICY IF EXISTS "Admins can manage all blogs" ON blogs;

    DROP POLICY IF EXISTS "Users can manage own files" ON files;
    DROP POLICY IF EXISTS "Admins can manage all files" ON files;
    DROP POLICY IF EXISTS "Public Read Files" ON files;
END $$;

-- Profiles Policies
CREATE POLICY "Users can read own profile" ON profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Admins can read all profiles" ON profiles FOR SELECT USING (public.is_admin());
CREATE POLICY "Admins can delete users except superadmin" ON profiles FOR DELETE USING (public.is_admin() AND email <> 'ishoracharya977@gmail.com');

-- Blogs policies
CREATE POLICY "Public Read Blogs" ON blogs FOR SELECT USING (true);
CREATE POLICY "Users can insert own blogs" ON blogs FOR INSERT WITH CHECK (auth.uid() = author_id);
CREATE POLICY "Users can delete own blogs" ON blogs FOR DELETE USING (auth.uid() = author_id);
CREATE POLICY "Admins can manage all blogs" ON blogs FOR ALL USING (public.is_admin());

-- Files policies
CREATE POLICY "Users can manage own files" ON files FOR ALL USING (auth.uid() = author_id);
CREATE POLICY "Admins can manage all files" ON files FOR ALL USING (public.is_admin());
CREATE POLICY "Public Read Files" ON files FOR SELECT USING (true);

-- 6. One-time Migration: Sync career views from existing blogs
DO $$
BEGIN
  UPDATE profiles p
  SET views_total = (
    SELECT COALESCE(SUM(views), 0)
    FROM blogs b
    WHERE b.author_id = p.id
  )
  WHERE EXISTS (SELECT 1 FROM blogs b WHERE b.author_id = p.id);
END $$;

-- 7. Analytics & Tracking Table
CREATE TABLE IF NOT EXISTS analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  visitor_id UUID DEFAULT gen_random_uuid(),
  source TEXT, -- 'mail', 'random'
  traffic_type TEXT, -- 'link', 'direct'
  age_group TEXT, -- '0-10', '11-20', etc.
  gender TEXT, -- 'male', 'female', 'other'
  browser TEXT,
  device TEXT,
  location TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE analytics ENABLE ROW LEVEL SECURITY;

-- Analytics Policies
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Public Insert Analytics" ON analytics;
    DROP POLICY IF EXISTS "Admins Read Analytics" ON analytics;
END $$;

CREATE POLICY "Public Insert Analytics" ON analytics FOR INSERT WITH CHECK (true);
CREATE POLICY "Admins Read Analytics" ON analytics FOR SELECT USING (public.is_admin());

-- 8. Newsletter Subscribers Table
CREATE TABLE IF NOT EXISTS subscribers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'unsubscribed')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE subscribers ENABLE ROW LEVEL SECURITY;

-- Subscribers Policies
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Public Insert Subscribers" ON subscribers;
    DROP POLICY IF EXISTS "Admins Read Subscribers" ON subscribers;
    DROP POLICY IF EXISTS "Admins Manage Subscribers" ON subscribers;
END $$;

CREATE POLICY "Public Insert Subscribers" ON subscribers FOR INSERT WITH CHECK (true);
CREATE POLICY "Admins Read Subscribers" ON subscribers FOR SELECT USING (public.is_admin());
CREATE POLICY "Admins Manage Subscribers" ON subscribers FOR ALL USING (public.is_admin());

-- 9. Blog Comments Table
CREATE TABLE IF NOT EXISTS blog_comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blog_id BIGINT REFERENCES blogs(id) ON DELETE CASCADE NOT NULL,
  author_name TEXT NOT NULL,
  author_email TEXT NOT NULL,
  comment_text TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE blog_comments ENABLE ROW LEVEL SECURITY;

-- Comments Policies
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Public Insert Comments" ON blog_comments;
    DROP POLICY IF EXISTS "Public Read Approved Comments" ON blog_comments;
    DROP POLICY IF EXISTS "Admins Manage Comments" ON blog_comments;
END $$;

CREATE POLICY "Public Insert Comments" ON blog_comments FOR INSERT WITH CHECK (true);
CREATE POLICY "Public Read Approved Comments" ON blog_comments FOR SELECT USING (status = 'approved');
CREATE POLICY "Admins Manage Comments" ON blog_comments FOR ALL USING (public.is_admin());

-- 10. Blog Reactions Table (Likes)
CREATE TABLE IF NOT EXISTS blog_reactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blog_id BIGINT REFERENCES blogs(id) ON DELETE CASCADE NOT NULL,
  reaction_type TEXT DEFAULT 'like' CHECK (reaction_type IN ('like', 'love', 'insightful')),
  user_identifier TEXT NOT NULL, -- Could be user_id or IP address for anonymous
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  UNIQUE(blog_id, user_identifier, reaction_type)
);

ALTER TABLE blog_reactions ENABLE ROW LEVEL SECURITY;

-- Reactions Policies
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Public Insert Reactions" ON blog_reactions;
    DROP POLICY IF EXISTS "Public Read Reactions" ON blog_reactions;
    DROP POLICY IF EXISTS "Public Delete Own Reactions" ON blog_reactions;
END $$;

CREATE POLICY "Public Insert Reactions" ON blog_reactions FOR INSERT WITH CHECK (true);
CREATE POLICY "Public Read Reactions" ON blog_reactions FOR SELECT USING (true);
CREATE POLICY "Public Delete Own Reactions" ON blog_reactions FOR DELETE USING (true);
